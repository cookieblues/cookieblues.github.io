I"îT<p>Now we know a bit about machine learning: it involves models. Machine learning attempts to model data in order to make predictions about the data. In the previous post we dove into the inner functions of a model, and that is very much what machine learning is about. Yet, it‚Äôs only half of it, really. The other half has to do with the concept of prediction, and how we make sure our models predict well. This course doesn‚Äôt dabble that deep into this other half - but there are a few important topics in this regard that you should be aware of, as they pop up in machine learning all the time.</p>

<h3 id="model-selection-and-validation">Model selection and validation</h3>
<p>In the previous post, we went over polynomial regression. In the Python implementation, we went with a 4th order polynomial. However, perhaps $M=4$ isn‚Äôt the ‚Äòbest‚Äô choice for the order of the polynomial - but what is the ‚Äòbest‚Äô choice, and how do we find it?</p>

<p>Firstly, the order of our polynomial is set before the training process begins, and we call these special parameters in our model <strong>‚Äúhyperparameters‚Äù</strong>. Secondly, the process of figuring out the values of these hyperparameters is called <strong>hyperparameter optimization</strong> and is a part of <strong>model selection</strong>. Thirdly, as mentioned in the previous post, machine learning is mostly concerned with prediction, which means that we define the ‚Äòbest‚Äô model as the one that <strong>generalizes</strong> the best on future data, i.e. which model would perform the best on data it wasn‚Äôt trained on?</p>

<p><span class="marginnote">Note that the evaluation metric can be different from the objective function. In fact, it often times is.</span>
To figure this out, we usually want to come up with some kind of <strong>evaluation metric</strong>. Then we divide our training dataset into 3 parts: a <strong>training</strong>, a <strong>validation</strong> (sometimes called <strong>development</strong>), and a <strong>test</strong> dataset.<span class="marginnote">Commonly the new training dataset is $80\%$ of the original, and the validation and test datasets are $10\%$ each.</span> Then we train our model on the training dataset, perform model selection on the validation dataset, and do a final evaluation of the model on the test dataset. This way, we can determine the model with the lowest <strong>generalization error</strong>. The generalization error refers to the performance of the model on <strong>unseen data</strong>, i.e. data that the model hasn‚Äôt been trained on.</p>

<p style="text-align: center"><img src="http://localhost:4000/extra/bsmalea-notes-1b/model_selection_poly_reg.svg" /></p>

<p>Let‚Äôs go back to the polynomial regression example. In the image above I‚Äôve plotted the data points from the previous post together with the true function and $4$ different estimated polynomials of $4$ different orders: $2$, $4$, $6$, and $8$. As we increase the order of the polynomial, we increase what we call the <strong>complexity</strong> of our model, which roughly can be seen as correlated with the number of parameters in the model. So the more parameters our model has, roughly the more complex it is. As the order of the polynomial (the complexity of the model) increases, it begins approximating the data points better, until it perfectly goes through all the data points. Yet, if we perfectly match the data points in our training dataset, our model probably won‚Äôt generalize very well, because the data isn‚Äôt perfect; there‚Äôs always a bit of noise, which can also be seen above. When we end up fitting our model perfectly to out training dataset, which makes the model generalize poorly, we say that we are <strong>overfitting</strong>. In the image above, when the order is set to $8$ ($M=8$), we‚Äôre definitely overfitting. Conversely, when $M=2$, we could argue that we are <strong>underfitting</strong>, which means that the complexity of our model isn‚Äôt high enough to ‚Äòcapture the richness of variation‚Äô in our data. In other words, it doesn‚Äôt pick up on the patterns in the data.</p>

<h4 id="cross-validation">Cross-validation</h4>
<p>If you have limited data, you might feel disadvantaged with the $80$-$10$-$10$ technique, because the size of the validation and test set is small, thereby not being a proper representation of your entire training set. In the extreme case of only $10$ data points, this would result in a validation and test set of size $1$, which is not exactly a great sample size! Instead, different techniques called <strong>cross-validation</strong> can be applied. The most common is the <strong>k-fold cross-validation</strong> technique, where you divide your dataset $\mathcal{D} = \{ \left( \mathbf{x}_1, t_1 \right), \dots, \left(\mathbf{x}_N, t_N \right) \}$ into $k$ distinct subsets. By choosing $1$ of the $k$ subsets to be the validation set, and the rest $k-1$ subsets to be the training set, we can repeat this process $k$ times by choosing a different subset to be the validation set every time. This makes it possible to repeat the training-validation process $k$ times, eventually going through the entire original training set as both training and validation set.</p>

<!--
INSERT ANIMATION FOR CROSS-VALIDATION
-->

<h4 id="python-implementation">Python implementation</h4>
<p>Following the example from last post we can try and figure out the best order $M$ for our polynomial. We start be defining our evaluation metric; we will use the popular <strong>mean squared-error (MSE)</strong>, which is very closely related to the sum of squared errors (SSE) function that we looked at briefly in the last post. The MSE is defined as the mean of the squared differences between our predictions and the true values, formally</p>

\[\text{MSE} = \frac{1}{N} \sum_{n=1}^N \left( t_n - h(x_n,\mathbf{w}) \right)^2,\]

<p><span class="marginnote">The only difference between the mean squared-error and the sum of squared errors is that we‚Äôre now dividing by the number of data points.</span>
where $N$ is the number of data points, $h$ is our polynomial, $\mathbf{w}=\left(w_0, \dots, w_M \right)^\intercal$ are the coefficients of our polynomial (the model parameters), and $(x_n, t_n)$ is an input-target variable pair. Below is a simple Python implementation of MSE that takes NumPy arrays as input. Make sure that the <code class="highlighter-rouge">true</code> and <code class="highlighter-rouge">pred</code> arrays are the same length - this could be done with an assertion if needed.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">mse</span><span class="p">(</span><span class="n">true</span><span class="p">,</span> <span class="n">pred</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">((</span><span class="n">true</span><span class="o">-</span><span class="n">pred</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">true</span><span class="p">)</span></code></pre></figure>

<p>And below is an implementation of k-fold cross-validation. It yields the indices of the train and validation set for each fold. We only have to make sure that <code class="highlighter-rouge">n_splits</code> is not larger than <code class="highlighter-rouge">n_points</code>.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">kfold</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="n">n_splits</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">split_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_splits</span><span class="p">,</span> <span class="n">n_points</span> <span class="o">//</span> <span class="n">n_splits</span><span class="p">)</span>
    <span class="n">leftover</span> <span class="o">=</span> <span class="n">n_points</span> <span class="o">%</span> <span class="n">n_splits</span>
    <span class="n">split_sizes</span><span class="p">[:</span><span class="n">leftover</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_points</span><span class="p">)</span>
    <span class="n">current</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">split_size</span> <span class="ow">in</span> <span class="n">split_sizes</span><span class="p">:</span>
        <span class="n">val_idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">current</span><span class="p">:</span><span class="n">current</span><span class="o">+</span><span class="n">split_size</span><span class="p">]</span>
        <span class="n">train_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">val_idx</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">train_idx</span><span class="p">,</span> <span class="n">val_idx</span>
        <span class="n">current</span> <span class="o">+=</span> <span class="n">split_size</span></code></pre></figure>

<h3 id="the-no-free-lunch-theorem">The ‚Äúno free lunch‚Äù theorem</h3>
<p>While machine learning tries to come up with the best models, in actuality we empirically choose the best model when confronted with a task<span class="sidenote-number"></span><span class="sidenote">S. Raschka, ‚ÄúModel Evaluation, Model Selection, and Algorithm Selection in Machine Learning,‚Äù 2018.</span>. This is what model selection and validation, which we just learned about, does for us. A known theorem in machine learning (and optimization) is <strong>the ‚Äúno free lunch‚Äù theorem</strong><span class="sidenote-number"></span><span class="sidenote">D. H. Wolpert, ‚ÄúThe Lack of A Priori Distinctions Between Learning Algorithms,‚Äù 1996.</span>, which broadly says that there‚Äôs no universally best model. That is, you cannot say that one model is better than another model in all cases, e.g. mixture models are better than neural networks or vice-versa. This is why it‚Äôs important to learn about a plethora of models, so when you‚Äôre confronted with a task, you know not only to try one model and be content, if it‚Äôs doing alright or matches your expectation; there could be another model significantly outperforming, what you‚Äôre seeing.</p>

<h3 id="the-curse-of-dimensionality">The curse of dimensionality</h3>
<p>As mentioned in the beginning, this post is mainly about the issue of determining which models generalize the best. The ‚Äúno free lunch‚Äù theorem tells us that we can never say that one model is the best, and model selection and validation gives us a framework to actually determine the best model for a specific task; the <strong>curse of dimensionality</strong> is a common enemy in this determination, which is even inherent in our training data! The term was first coined by Richard E. Bellman in 1957<span class="sidenote-number"></span><span class="sidenote">R. E. Bellman, ‚ÄúDynamic Programming,‚Äù 1957.</span> to refer to the intractability of certain algorithms in high dimensionality. To facilitate the understanding of the curse of dimensionality, we‚Äôll go through an example of classification. As mentioned in the previous post, classification is a supervised learning task, where we have to organize our data points into discrete groups that we call classes.</p>

<p>So far we‚Äôve been looking at polynomial regression with only a $1$-dimensional input variable $x$. However, in most practical cases, we‚Äôll have to deal with data of high dimensionality, e.g. if humans were our observations, they could have multiple values describing them: height, weight, age, etc. In our example, we‚Äôll have $10$ data points $N=10$, $2$ classes $C=2$, and each data point is $3$-dimensional $D=3$.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mf">0.33</span><span class="p">,</span> <span class="mf">0.88</span><span class="p">,</span> <span class="mf">0.11</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.74</span><span class="p">,</span> <span class="mf">0.54</span><span class="p">,</span> <span class="mf">0.62</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.79</span><span class="p">,</span> <span class="mf">0.07</span><span class="p">,</span> <span class="mf">0.31</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.83</span><span class="p">,</span> <span class="mf">0.24</span><span class="p">,</span> <span class="mf">0.47</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.42</span><span class="p">,</span> <span class="mf">0.47</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.82</span><span class="p">,</span> <span class="mf">0.70</span><span class="p">,</span> <span class="mf">0.10</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.51</span><span class="p">,</span> <span class="mf">0.76</span><span class="p">,</span> <span class="mf">0.51</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.71</span><span class="p">,</span> <span class="mf">0.92</span><span class="p">,</span> <span class="mf">0.59</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.78</span><span class="p">,</span> <span class="mf">0.19</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">0.43</span><span class="p">,</span> <span class="mf">0.53</span><span class="p">,</span> <span class="mf">0.53</span><span class="p">]</span>
<span class="p">])</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span></code></pre></figure>

<p>The code snippet above shows our training dataset; <code class="highlighter-rouge">X</code> is our $10$ input variables of dimensionality $3$ (we have $3$ features), and <code class="highlighter-rouge">t</code> is our target variables, which in this case corresponds to $2$ classes. We can also see that the first $5$ data points belong to class $0$ and the last $5$ to class $1$; we have an equal distribution between our classes. If we plot the points using only the first feature (the first column in <code class="highlighter-rouge">X</code>), we get the plot underneath. A naive approach to classify the points would be to split the line into $5$ segments (each of length $0.2$), and then decide to classify all the points in this segment into class $0$ or $1$. In the image underneath I‚Äôve coloured the segments after the classification I would make. With this naive approach we get $3$ mistakes.</p>

<p style="text-align: center"><img src="http://localhost:4000/extra/bsmalea-notes-1b/one_dim_cod.svg" /></p>

<p>But let‚Äôs see if we can do better! Using the first $2$ features now gives us a grid (of $0.2$ by $0.2$ tiles) that we can now use for our naive classification model. As shown underneath, we can now classify the points such that we only make $1$ mistake.</p>

<p style="text-align: center"><img src="http://localhost:4000/extra/bsmalea-notes-1b/two_dim_cod.svg" /></p>

<p>If we use all $3$ features, we can classify all the points perfectly, which is illustrated underneath. This is because, we now have $0.2$ by $0.2$ by $0.2$ cubes. From this it might seem like using all $3$ features is better than just using $1$ or $2$, since we‚Äôre able to better classify our data points - but this is where the counterintuitive concept of the <strong>curse of dimensionality</strong> comes in, and I tell you that it‚Äôs <em>not</em> better to use all the features.</p>

<p style="text-align: center"><img src="http://localhost:4000/extra/bsmalea-notes-1b/three_dim_cod.gif" /></p>

<p>The issue relates to the proportion of our data points compared to our classification sections; with $1$ feature we had $10$ points and $5$ sections, i.e. $\frac{10}{5}=2$ points per section, with $2$ features we had $\frac{10}{5 \times 5}=0.4$ points per section, and with $3$ features we had $\frac{10}{5 \times 5 \times 5}=0.08$ points per section. As we add more features, the available data points in our <strong>feature space</strong> become exponentially sparser, which makes it easier to separate the data points. Yet, it‚Äôs not because of any pattern in the data, in actuality it‚Äôs just the nature of higher dimensional spaces. In fact, the data points I listed were randomly generated from a uniform distribution, so the ‚Äòpattern‚Äô we‚Äôre fitting to isn‚Äôt actually there at all - it‚Äôs a result of the increased dimensionality, which makes the available data points become sparser. Because of this inherent sparsity we end up overfitting, when we add more features to our data. Which means we need more data to avoid sparsity, and that‚Äôs the curse of dimensionality: as the number of features increase, our data become sparser, which results in overfitting, and we therefore need more data to avoid it.</p>

<p>The illustration underneath shows the exact thing, we just went over. The 100 points are randomly sampled from increasingly higher multivariate normal distributions and randomly assigned to a class. A hyperplane is found that tries to separate these points. As the dimensionality of the points increase, it becomes easier and easier to separate them. In fact, it‚Äôs always possible to perfectly separate N+1 points with N-dimensions.</p>

<p style="text-align: center"><img src="http://localhost:4000/extra/bsmalea-notes-1b/cod_final.svg" /></p>

<h3 id="blessing-of-non-uniformity">Blessing of non-uniformity</h3>

<p>So how do we avoid getting cursed? Luckily, the <strong>blessing of non-uniformity</strong><span class="sidenote-number"></span><span class="sidenote">P. Domingos, ‚ÄúA few useful things to know about machine learning,‚Äù Communications of the ACM, vol. 55, no. 10, pp. 78-87, 2012.</span> comes to our rescue! In most practical (real-world) scenarios our data are not spread out uniformly, but are instead concentrated in some places, which can nullify the curse of dimensionality a little bit. But what if it really is the curse of dimensionality, when we‚Äôre overfitting? There‚Äôs not a definitive answer, as it really depends on the dataset, but there is a related <a href="https://en.wikipedia.org/wiki/One_in_ten_rule" target="_blank">one in ten rule</a> of thumb; for every model parameter (roughly feature) we want at least $10$ data points. Some better options fall under the topic of <strong>dimensionality reduction</strong>, which we will look at later on in the course.</p>

<h3 id="summary">Summary</h3>
<ul>
  <li><strong>Hyperparameters</strong> are the parameters in a model that <strong>are determined before training</strong> the model.</li>
  <li>Model selection refers to the proces of <strong>choosing the model that best generalizes</strong>.</li>
  <li><strong>Training and validation sets</strong> are used to <strong>simulate unseen data</strong>.</li>
  <li><strong>Overfitting</strong> happens when our model <strong>performs well on our training dataset but generalizes poorly</strong>.</li>
  <li><strong>Underfitting</strong> happens when our model <strong>performs poorly on both our training dataset and unseen data</strong>.</li>
  <li>We can see if our model generalizes well with cross-validation techniques.</li>
  <li>The <strong>mean squared-error</strong> or <strong>MSE</strong> is a common evaluation metric.</li>
  <li>The <strong>‚Äúno free lunch‚Äù</strong> theorem tells us that there is <strong>no best model</strong>.</li>
  <li>The <strong>more features</strong>, the <strong>higher risk of overfitting</strong> is the curse of dimensionality in a nut shell.</li>
  <li>The <strong>blessing of non-uniformity counteracts the curse of dimensionality</strong> in most practical scenarios.</li>
  <li><strong>Dimensionality reduction</strong> can be a tool to remedy the curse of dimensionality.</li>
</ul>
:ET