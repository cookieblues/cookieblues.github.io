I"
W<p>The <a href="https://www.itu.dk/" target="_blank">IT University of Copenhagen (ITU)</a> conducts a student evaluation of the courses and the university itself each semester. The evaluations are one of the only ways that students can provide feedback to the lecturers, which can improve the learning environment, course material, exercises, and so on. The evaluations are also packed with interesting data, and naturally, as a data science student, I cannot keep my hands off them.<br />
This analysis of the evaluations will be a series of posts, where I’ll dive into some of the interesting data that we can get out of the evaluations. On top of that, these first few posts will serve as notes for the first project of the <a href="https://mit.itu.dk/ucs/cb_www/course.sml?course_id=2708256&amp;mode=search&amp;lang=en&amp;print_friendly_p=t&amp;goto=1547640286.000" target="_blank">First Year Project</a> course. This time we’ll focus on elementary <a href="https://en.wikipedia.org/wiki/Data_scraping" target="_blank">data scraping</a>, which in its broadest sense is the act of collecting data.</p>

<h3 id="browser-automation-with-selenium">Browser automation with Selenium</h3>
<p>To scrape data, firstly, we’ll need to find a place where our wanted data is located and free to use. Luckily, the ITU has made the evaluations publicly available on <a href="https://en.itu.dk/about-itu/organisation/facts-and-figures/quality-and-educational-environment/course-evaluation" target="_blank">their website</a>. Also, I spoke to someone at ITU, and they said that we can do anything we want with the evaluations, as long as the data is publicly available. So far, so good.<br />
Secondly, now we’ll have to come up with a way to actually collect the data. The link on ITU’s website leads to a webpage, where we can choose specific evaluation results for any evaluation period we desire. While the number of evaluation periods is small enough for us to manually collect the results, there are several benefits to not collecting the results this way. First of all, by avoiding performing a task the naive way we might learn something new. Second of all, if our method is broad enough, it might generalize to other tasks and save us time in the long run. Third of all, if we were to manually collect the results, the naive way would be to download the HTML pages, and afterwards clean the data for our purpose - however, we can clean the data as we collect it, if we don’t do it the naive way.<br />
Now, there are many ways to scrape data from websites, and depending on the specific website there might be a plethora of tools better suited for your purpose (public APIs, specific modules, etc.), especially if you want to scrape data from more popular sites. In this brief introduction to data scraping, we’ll utilize <a href="https://github.com/SeleniumHQ/Selenium" target="_blank">Selenium</a>, which is definitely not the most efficient library for browser automation, but we don’t have a lot of data to scrape, and we want something that is user-friendly.
<!--more--></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">selenium</span> <span class="kn">import</span> <span class="n">webdriver</span>

<span class="n">driver</span> <span class="o">=</span> <span class="n">webdriver</span><span class="o">.</span><span class="n">Firefox</span><span class="p">()</span>
<span class="n">url</span> <span class="o">=</span> <span class="s">"https://mit.itu.dk/ucs/evaluation/public.sml?lang=english"</span>
<span class="n">driver</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span></code></pre></figure>

<p>We’re going to use the WebDriver API from Selenium, which makes browser automation almost as intuitive as normal web browsing. By “getting” the URL, a new Firefox window will open, which is administered by the driver. We can now manoeuvre around on the webpage by using the driver’s functions and with a little bit of knowledge of <a href="https://en.wikipedia.org/wiki/XPath" target="_blank">XPath</a>. By right-clicking on the webpage and looking at the page source, we can see the radio buttons, which dictate the results we get, can be identified by their value. For now, we’ll look at the evaluations of ITU in general, which is the radio button of value 0. We find the element through the driver, and click on it.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">driver</span><span class="o">.</span><span class="n">find_element_by_xpath</span><span class="p">(</span>
    <span class="s">"//input[@type='RADIO'][@value=0]"</span>
<span class="p">)</span><span class="o">.</span><span class="n">click</span><span class="p">()</span></code></pre></figure>

<p>Then we want to select the evaluation period. We can use one of the WebDriver’s support classes for this. With a bit of foresight, we can tell that we’re going to do this a lot, so let’s write a function that can do this for us. If we inspect the drop-down list, we can see that the different choices are called “2018october”, “2018march”, “2017october”, “2017march”, etc. (except for “2002april” which is the odd one out). We can use this as input in the function (as well as the driver). The second thing we can use is the submit method of a form in Selenium. By inspecting the site a bit more, we find that the evaluation results and periods all lie in a form. After choosing our desired evaluation results and period, we can submit the form and get to the next page.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">selenium.webdriver.support.ui</span> <span class="kn">import</span> <span class="n">Select</span>

<span class="k">def</span> <span class="nf">enter_eval_period</span><span class="p">(</span><span class="n">period</span><span class="p">,</span><span class="n">driver</span><span class="p">):</span>
    <span class="n">evaluation_form</span> <span class="o">=</span> <span class="n">driver</span><span class="o">.</span><span class="n">find_element_by_xpath</span><span class="p">(</span><span class="s">"//form[1]"</span><span class="p">)</span>
    <span class="n">evaluation_period</span> <span class="o">=</span> <span class="n">Select</span><span class="p">(</span><span class="n">evaluation_form</span><span class="o">.</span><span class="n">find_element_by_name</span><span class="p">(</span><span class="s">"dir"</span><span class="p">))</span>
    <span class="n">evaluation_period</span><span class="o">.</span><span class="n">select_by_value</span><span class="p">(</span><span class="n">period</span><span class="p">)</span>
    <span class="n">evaluation_form</span><span class="o">.</span><span class="n">submit</span><span class="p">()</span>

<span class="n">enter_eval_period</span><span class="p">(</span><span class="s">"2018october"</span><span class="p">,</span><span class="n">driver</span><span class="p">)</span></code></pre></figure>

<p>The next page lets us choose, which students (part- or full-time) we want the evaluations for. While I don’t want the analysis to be overly thorough, I will scrape the evaluations from part-time students and full-time students individually - even though there are way fewer part-time students. Since both boxes are checked, we’ll just make a function that unchecks the full-time students.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">pick_parttime</span><span class="p">(</span><span class="n">driver</span><span class="p">):</span>
    <span class="n">student_form</span> <span class="o">=</span> <span class="n">driver</span><span class="o">.</span><span class="n">find_element_by_xpath</span><span class="p">(</span><span class="s">"//form[1]"</span><span class="p">)</span>
    <span class="n">student_form</span><span class="o">.</span><span class="n">find_element_by_xpath</span><span class="p">(</span>
        <span class="s">"//input[@type='CHECKBOX'][@value='orduni']"</span>
    <span class="p">)</span><span class="o">.</span><span class="n">click</span><span class="p">()</span>
    <span class="n">student_form</span><span class="o">.</span><span class="n">submit</span><span class="p">()</span>

<span class="n">pick_part_time</span><span class="p">(</span><span class="n">driver</span><span class="p">)</span></code></pre></figure>

<h3 id="scraping-data-with-beautifulsoup-and-pandas">Scraping data with BeautifulSoup and Pandas</h3>
<p>BeautifulSoup is a wonderful library for parsing HTML documents, and it works naturally together with Pandas. We’re currently in the part-time students’ evaluations for October, 2018. We have some numerical data at the top of the page in a table, and the textual data is underneath in lists. To get the table data, we can use BeautifulSoup to parse the page source, find the table we need, and then use Pandas to put the table in a DataFrame.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>

<span class="k">def</span> <span class="nf">get_numerical</span><span class="p">(</span><span class="n">driver</span><span class="p">):</span>
    <span class="n">soup_page</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">driver</span><span class="o">.</span><span class="n">page_source</span><span class="p">)</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">soup_page</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">"table"</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_html</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">table</span><span class="p">),</span><span class="n">header</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s">"Unnamed: 0"</span><span class="p">:</span><span class="s">"statement"</span><span class="p">})</span>

<span class="n">numerical_df</span> <span class="o">=</span> <span class="n">get_numerical</span><span class="p">(</span><span class="n">driver</span><span class="p">)</span></code></pre></figure>

<p>To briefly explain the function: it turns out, it’s the fourth (index three) table that we need. Pandas’ read_html function returns a list, since it expects a list of tables, however, we only give it one, and therefore we take index zero. We also set the second (index one) row to be the header as the first row is irrelevant. Lastly, we rename the first column for readability. This gives us the numerical data in a DataFrame.</p>

<p>The next thing we need is the textual data. This is a little more complicated, since the textual data is wrapped in a lot of lists. By inspecting the page source, we can see that all the textual evaluations are wrapped in ul tags. By further inspection, every fourth ul tag are “Good things about the IT University”, and the ones following are “Things that could be improved”. We could grab all the ul tags and use some regular expressions to get what we want, <a href="https://stackoverflow.com/a/1732454" target="_blank">but you should not attempt to parse HTML with regex</a>. In each ul tag we have li tags, where only a few contain text that we need. The function below gets us exactly what we want.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">get_textual_1</span><span class="p">(</span><span class="n">driver</span><span class="p">):</span>
    <span class="n">soup_page</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">driver</span><span class="o">.</span><span class="n">page_source</span><span class="p">)</span>
    <span class="n">good</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">bad</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">ul</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">soup_page</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">"ul"</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">bad</span> <span class="o">+=</span> <span class="p">[</span><span class="n">evaluation</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span> <span class="k">for</span> <span class="n">evaluation</span> <span class="ow">in</span> <span class="n">ul</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">"li"</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">idx</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">good</span> <span class="o">+=</span> <span class="p">[</span><span class="n">evaluation</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span> <span class="k">for</span> <span class="n">evaluation</span> <span class="ow">in</span> <span class="n">ul</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">"li"</span><span class="p">)]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">good</span><span class="p">),</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">bad</span><span class="p">)],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="s">"good"</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="s">"bad"</span><span class="p">})</span>

<span class="n">textual_df</span> <span class="o">=</span> <span class="n">get_textual_1</span><span class="p">(</span><span class="n">driver</span><span class="p">)</span></code></pre></figure>

<p>You might have noticed that I called this function get_textual_1, and that’s because a few of the evaluations follow a slightly different template. For the other template we can use the following function, which follows the same idea.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">get_textual_2</span><span class="p">(</span><span class="n">driver</span><span class="p">):</span>
    <span class="n">soup_page</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">driver</span><span class="o">.</span><span class="n">page_source</span><span class="p">)</span>
    <span class="n">good</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">bad</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">ol</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">soup_page</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">"ol"</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">idx</span><span class="p">:</span>
            <span class="n">bad</span> <span class="o">+=</span> <span class="p">[</span><span class="n">evaluation</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span> <span class="k">for</span> <span class="n">evaluation</span> <span class="ow">in</span> <span class="n">ol</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">"li"</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">good</span> <span class="o">+=</span> <span class="p">[</span><span class="n">evaluation</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span> <span class="k">for</span> <span class="n">evaluation</span> <span class="ow">in</span> <span class="n">ol</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">"li"</span><span class="p">)]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">good</span><span class="p">),</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">bad</span><span class="p">)],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="s">"good"</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="s">"bad"</span><span class="p">})</span>

<span class="n">textual_df</span> <span class="o">=</span> <span class="n">get_textual_2</span><span class="p">(</span><span class="n">driver</span><span class="p">)</span></code></pre></figure>

<p>If we use the wrong function for an evaluation template, we’ll return an empty DataFrame. We can therefore make one function that takes care of both scenarios.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">get_textual</span><span class="p">(</span><span class="n">driver</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">get_textual_1</span><span class="p">(</span><span class="n">driver</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">get_textual_1</span><span class="p">(</span><span class="n">driver</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">get_textual_2</span><span class="p">(</span><span class="n">driver</span><span class="p">)</span></code></pre></figure>

<p>We can now go back, enter the full-time students’ evaluations, scrape their data, and go all the way back to choosing a different period. A simple back method exists for the driver.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">driver</span><span class="o">.</span><span class="n">back</span><span class="p">()</span></code></pre></figure>

<p>Coming back from the part-time students, we have to uncheck the part-time students and check the full-time students.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">pick_fulltime</span><span class="p">(</span><span class="n">driver</span><span class="p">):</span>
    <span class="n">students_form</span> <span class="o">=</span> <span class="n">driver</span><span class="o">.</span><span class="n">find_element_by_xpath</span><span class="p">(</span><span class="s">"//form[1]"</span><span class="p">)</span>
    <span class="n">students_form</span><span class="o">.</span><span class="n">find_element_by_xpath</span><span class="p">(</span>
        <span class="s">"//input[@type='CHECKBOX'][@value='openuni']"</span>
    <span class="p">)</span><span class="o">.</span><span class="n">click</span><span class="p">()</span>
    <span class="n">students_form</span><span class="o">.</span><span class="n">find_element_by_xpath</span><span class="p">(</span>
        <span class="s">"//input[@type='CHECKBOX'][@value='orduni']"</span>
    <span class="p">)</span><span class="o">.</span><span class="n">click</span><span class="p">()</span>
    <span class="n">students_form</span><span class="o">.</span><span class="n">submit</span><span class="p">()</span></code></pre></figure>

<p>That’s it! We can now go through all the different evaluation periods, scrape the data, and save the DataFrames.</p>

:ET