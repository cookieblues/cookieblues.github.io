I"¢S<p>It seems, most people derive their definition of machine learning from a quote from Arthur Lee Samuel in 1959: ‚ÄúProgramming computers to learn from experience should eventually eliminate the need for much of this detailed programming effort.‚Äù The interpretation to take away from this is that ‚Äúmachine learning is the field of study that gives computers the ability to learn without being explicitly programmed.‚Äù</p>

<p>While Arthur Lee Samuel first coined the term ‚Äúmachine learning‚Äù in 1959<span class="sidenote-number"></span><span class="sidenote">R. Kohavi and F. Provost, ‚ÄúGlossary of terms,‚Äù Machine Learning, vol. 30, no. 2‚Äì3, pp. 271‚Äì274, 1998.</span>,  and machine learning <a href="https://en.wikipedia.org/wiki/AI_winter">‚Äòtook off‚Äô after the 1970s</a>, the underlying theory applied in machine learning have existed long before, e.g. the method of least-squares was first published by Adrien-Marie Legendre in 1805<span class="sidenote-number"></span><span class="sidenote">A. M. Legendre, ‚ÄúNouvelles m√©thodes pour la d√©termination des orbites des com√®tes,‚Äù 1805.</span>, and Bayes‚Äô theorem, which is the cornerstone of Bayesian statistics that has taken off in the 21st century, was first underpinned by Thomas Bayes in 1763<span class="sidenote-number"></span><span class="sidenote">T. Bayes and R. Price, ‚ÄúAn essay towards solving a problem in the doctrine of chances,‚Äù in a letter to J. Canton, 1763.</span>.</p>

<!---
INSERT TIMELINE
-->

<p>Machine learning draws a lot of its methods from statistics, but there is a distinctive difference between the two areas: <strong>statistics is mainly concerned with estimation</strong>, whereas <strong>machine learning is mainly concerned with prediction</strong>. This distinction makes for great differences, as we will see soon enough.</p>

<h3 id="categories-of-machine-learning">Categories of machine learning</h3>
<!--
WRITE OUT THAT CLASSIFICATION/REGRESSION ARE SUPERVISED AND CLUSTERING/DENSITY ESTIMATION ARE UNSUPERVISED
-->
<p>There are many different machine learning methods that solve different tasks and putting them all in rigid categories can be quite a task on its own. My posts will cover 2 fundamental ones; <strong>supervised</strong> learning and <strong>unsupervised</strong> learning, which can further be divided into smaller categories ash shown in the image underneath.</p>

<!---
INSERT ANIMATION
-->
<p><img src="http://localhost:4000/extra/bsmalea-notes-1a/categories_of_ml_2.svg" /></p>

<p>It‚Äôs important to note that these categories are not strict, e.g. dimensionality reduction isn‚Äôt always unsupervised, and you can use density estimation for clustering and classification.</p>

<h4 id="supervised-learning">Supervised learning</h4>
<!--
MORE EXPLICIT THAT THERE ARE TARGET VALUES
MAYBE MORE EXPLICIT THAT THERE ARE ONE TARGET FOR EACH INPUT
-->
<p>Supervised learning refers to a subset of machine learning tasks, where we‚Äôre given a dataset $\mathcal{D} = \left\{ (\mathbf{x}_1,\mathbf{t}_1), \dots, (\mathbf{x}_N,\mathbf{t}_N) \right\}$ of $N$ input-output pairs, and our goal is to come up with a function $h$ from the inputs $\mathbf{x}$ to the outputs $\mathbf{t}$. In more layman‚Äôs terms: we are given a dataset with predetermined labels that we want to predict - hence the learning is <em>supervised</em>, i.e. we are handed some data that tells us, what we want to predict. Each input-output pair refers to observations, where we want to predict the output from the input. Each input variable $\mathbf{x}$ is a $D_1$-dimensional vector (or a scalar), representing the observation with numerical values. The different dimensions of the input variable are commonly called <strong>features</strong> or <strong>attributes</strong>. Likewise, each output or <strong>target</strong> variable $\mathbf{t}$ is a $D_2$-dimensional vector (but most often just a scalar).</p>

<p>In <strong>classification</strong> the possible values for the target variables form a finite number of discrete categories $t \in \{ C_1, \dots, C_k \}$ commonly called <strong>classes</strong>. An example of this could be trying to classify olive oil into geographical regions (our classes) based on various aspects (our features) of the olive oils<span class="sidenote-number"></span><span class="sidenote">J. Gromadzka and W. Wardencki, ‚ÄúTrends in Edible Vegetable Oils Analysis. Part B. Application of Different Analytical Techniques,‚Äù 2011.</span>. The features could be concentrations of acids in the olive oils, and the classes could be northern and southern France. Another classic example is recognizing handwritten digits<span class="sidenote-number"></span>. Given an image of $28 \times 28$ pixels,<span class="sidenote">Y. LeCun et al., ‚ÄúGradient-based learning applied to document recognition,‚Äù 1998.</span> we can represent each image as a $784$-dimensional vector, which will be our input variable, and our target variables will be scalars from $0$ to $9$ each representing a distinct digit.</p>

<p>You might‚Äôve heard of <strong>regression</strong> before. Like classification, we are given a target variable, but in regression it is continuous instead of discrete, i.e. $t \in \mathbb{R}$. An example of regression that I‚Äôm fairly interested in is forecasting election results from polling. In this case, your features would obviously be the polls, but it could also include other data like days until the election or perhaps the parties‚Äô media attention. The target variables are naturally the share of the votes for each party. Another example of regression could be predicting how much a house will be sold for. In this case, the features could be any measurements about the house, the location, and what other similar houses have been sold for recently - the target variable is the selling price of the house.</p>

<h4 id="unsupervised-learning">Unsupervised learning</h4>
<p>Another subset of machine learning tasks fall under unsupervised learning, where we‚Äôre only given a dataset $\mathcal{D} = \left\{ \mathbf{x}_1, \dots, \mathbf{x}_N \right\}$ of $N$ input variables. In contrast to supervised learning, we‚Äôre not told what we want to predict, i.e., we‚Äôre not given any target variables. The goal of unsupervised learning is then to find patterns in the data.</p>

<p>The image of categories above divides unsupervised learning into 3 subtasks, the first one being <strong>clustering</strong>, which, as the name suggests, refers to the task of discovering ‚Äòclusters‚Äô in the data. We can define a cluster to be <strong>a group of observations that are more similar to each other than to observations in other clusters</strong>. Let‚Äôs say we had to come up with clusters for a basketball, a carrot, and an apple. Firstly, we could create clusters based on shapes, in which case the basketball and the apple are both round, but the carrot isn‚Äôt. Secondly, we could also cluster by use, in which case the carrot and apple are foods, but the basketball isn‚Äôt. Finally, we might cluster by colour, in which case the basketball and the carrot are both orange, but the apple isn‚Äôt. All three are examples are valid clusters, but they‚Äôre clustering different things.</p>

<p>Then we have <strong>density estimation</strong>, which is the task of fitting probability density functions to the data. It‚Äôs important to note that density estimation is often done in conjunction to other tasks like classification, e.g. based on the given classes of our observations, we can use density estimation to find the distributions of each class and thereby (based on the class distributions) classify new observations. An example of density estimation could be finding extreme outliers in data, i.e., finding data that are highly unlikely to be generated from the density function you fit to the data.</p>

<p>Finally, <strong>dimensionality reduction</strong>, as the name suggests, reduces the number of features of the data that we‚Äôre dealing with. Just like density estimation, this is often done in conjunction with other tasks. Let‚Äôs say, we were going to do a classification task, and our input variables have 50 features - if we could do the same task equally well after reducing the number of features to 5, we could save a lot of time on computation. Having a high number of dimensions in our input variables can also cause unwanted behaviour in our model, known as the curse of dimensionality, but that‚Äôs a tale for another time.</p>

<h3 id="example-polynomial-regression">Example: polynomial regression</h3>
<p>Let‚Äôs go through an example of machine learning. This is also to get familiar with the machine learning terminology. We‚Äôre going to implement a model called <em>polynomial regression</em>, where we try and fit a polynomial to our data. Given a training dataset of $N$ input variables $x \in \mathbb{R}$ (notice the input variables are one-dimensional) with corresponding target variables $t \in \mathbb{R}$, our objective is to fit a polynomial that yields values $\hat{t}$ of target variables for new values $\hat{x}$ of the input variable. We‚Äôll do this by estimating the coefficients of the polynomial</p>

\[h(x, \mathbf{w}) = w_0 + w_1 x + w_2 x^2 + \dots + w_M x^M = \sum_{m=0}^M w_m x^m, \quad \quad (1)\]

<p>which we refer to as the <strong>parameters</strong> or <strong>weights</strong> of our model. $M$ is the order of our polynomial, and $\mathbf{w} = \left( w_0, w_1, \dots, w_M \right)^\intercal$ denotes all our parameters, i.e. we have $M+1$ parameters for our $M$th order polynomial.</p>

<p><span class="marginnote">In the next post we‚Äôll discuss exactly what we mean by ‚Äòbest‚Äô values.</span>
Now, the objective is to estimate the ‚Äòbest‚Äô values for our parameters. To do this, we define what is called an <strong>objective function</strong> (also sometimes called <strong>error</strong> or <strong>loss</strong> function). We construct our objective function such that it outputs a value that tells us how our model is performing. For this task, we define the objective function as the sum of the squared differences between the predictions of our polynomial and the corresponding target variables, i.e.</p>

\[E(\mathbf{w}) = \sum_{n=1}^N \left( t_n - h(x_n, \mathbf{w}) \right)^2, \quad \quad (2)\]

<p>and if we substitute $h(x_n, \mathbf{w})$ with the right-hand side of $(1)$, we get</p>

\[E(\mathbf{w}) =  \sum_{n=1}^N \left( t_n - \sum_{m=0}^M w_m x^m \right)^2.\]

<p>Let‚Äôs take a minute to understand what $(2)$ is saying. The term in the parantheses on the right-hand side is commonly called the $n$th residual and is denoted $r_n = t_n - h(x_n, \mathbf{w})$. It‚Äôs the difference between the output of our polynomial for input variable $x_n$ and the corresponding target variable $t_n$. The difference can be both negative and positive depending on whether the output of our polynomial is lower or higher than the target.<span class="marginnote">Note that since we‚Äôre squaring all the differences, the value of the objective function $E$ cannot be lower than 0 - and if it‚Äôs exactly 0, then our model is making no mistakes, i.e., it is predicting the exact value of the target every time.</span> We therefore square these differences and add them all up in order to get a value that tells us how our polynomial is performing.</p>

<p>This objective function is called the <a href="https://en.wikipedia.org/wiki/Residual_sum_of_squares">residual sum of squares or sum of the squared residuals</a> and is often used as a way to measure the performance of regression models in machine learnig. The image below shows the differences between the polynomium that we‚Äôre estimating and the data we‚Äôre given. These differences are the errors (or residuals) that the objective function is taking the square of and summing.</p>

<p><img src="http://localhost:4000/extra/bsmalea-notes-1a/residuals.svg" /></p>

<p>So far, so good! Since the objective function tells us how well we‚Äôre doing, and the lower it is, the better we‚Äôre doing, we will try and find the minimum of the objective function. That is, we want to find the values for our parameters $\mathbf{w}$ that give us the lowest value for $E$. The process of determining the values for our parameters is called the <strong>training</strong> or <strong>learning</strong> process.</p>

<!-- Recall from the <a href="http://localhost:4000/bslialo-notes-9b">notes about extrema</a> that-->
<p>To find the minimum of a function, we take the derivative, set it equal to 0, and solve for our parameters $\mathbf{w}$. Since we have a lot of parameters, we‚Äôll take the partial derivative of $E$ with respect to the $i$th parameter $w_i$, set it equal to 0, and solve for it. This will give us a linear system of $M+1$ equations with $M+1$ unknowns (our parameters $\mathbf{w}$). We‚Äôll go over the derivation of the solution to this problem in the next post, but for now we‚Äôll just have it given. The solution to the system of equations is</p>

\[\hat{\mathbf{w}} = \left( \mathbf{X}^\intercal \mathbf{X} \right)^{-1} \mathbf{X}^\intercal \textbf{\textsf{t}}, \quad \quad (3)\]

<p>where $\textbf{\textsf{t}}$ denotes all our target variables as a column vector $\textbf{\textsf{t}} = \left( t_1, t_2, \dots, t_N \right)^\intercal$, and $\mathbf{X}$ is called the <strong>design matrix</strong> and is defined as</p>

\[\mathbf{X} = \begin{pmatrix}
1 &amp; x_1 &amp; x_1^2 &amp; \cdots &amp; x_1^M \\
1 &amp; x_2 &amp; x_2^2 &amp; \cdots &amp; x_2^M \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; x_N &amp; x_N^2 &amp; \cdots &amp; x_N^M \\
\end{pmatrix}. \quad \quad (4)\]

<p>To sum up: we‚Äôre given $N$ pairs of input and target variables $\left\{ (x_1, t_1), \dots, (x_N, t_N) \right\}$, and we want to fit a polynomial to the data of the form $(1)$ such that the value of our polynomium $h(x_i, \mathbf{w})$ is as close to $t_i$ as possible. We do this by finding values for the parameters $\mathbf{w}$ that minimize the objective function defined in $(2)$, and the solution to this is given in $(3)$.</p>

<h4 id="python-implementation-of-polynomial-regression">Python implementation of polynomial regression</h4>
<p>Let‚Äôs try and implement our model! We‚Äôll start with the dataset shown underneath, where <code class="highlighter-rouge">x</code> is our input variables and <code class="highlighter-rouge">t</code> is our target variables.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.8</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.6</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.4</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">4.9</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.8</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.6</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span> <span class="mf">2.9</span><span class="p">,</span> <span class="mf">5.6</span><span class="p">])</span></code></pre></figure>

<p>To begin with we can define the order of our polynomial, find the number of data points, and then set up our design matrix.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">M</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span></code></pre></figure>

<p>If we look at the definition of the design matrix in $(4)$, we can fill out the columns of our design matrix with the following for-loop.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">X</span><span class="p">[:,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="n">m</span></code></pre></figure>

<p>Now we can find the parameters with the solution in $(3)$.</p>

<p><span class="marginnote">The <code class="highlighter-rouge">@</code> performs matrix multiplication.</span></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">X</span><span class="p">)</span> <span class="o">@</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">t</span></code></pre></figure>

<p>Using NumPy‚Äôs <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.poly1d.html"><code class="highlighter-rouge">poly1d</code> function</a> we can generate outputs for our polynomial.
<!--
MAYBE SHOW SMALL TEST OF poly1d FUNCTION
--></p>

<p><span class="marginnote">We flip the weights to accommodate the input of the <code class="highlighter-rouge">poly1d</code> function.</span></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">x_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">t_</span> <span class="o">=</span> <span class="n">h</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span></code></pre></figure>

<p>Now we can plot our estimated polynomial with our data points. I‚Äôve also plotted the true function that the points were generated from.</p>

<p><img src="http://localhost:4000/extra/bsmalea-notes-1a/poly_reg.svg" /></p>

<h3 id="summary">Summary</h3>
<ul>
  <li>Machine learning studies <strong>how to make computers learn on their own</strong> with the goal of <strong>predicting the future</strong>.</li>
  <li><strong>Supervised learning</strong> refers to machine learning tasks, where we are given <strong>labeled data</strong>, and we want to predict those labels.</li>
  <li><strong>Unsupervised learning</strong>, as it suggests, refers to tasks, where we are <em>not</em> provided with labels for our data.</li>
  <li><strong>Features</strong> refer to the <strong>attributes</strong> (usually columns) of our data e.g. height, weight, shoe size, etc., if our observations are humans.</li>
  <li><strong>Classification and regression are supervised</strong> tasks, <strong>clustering, density estimation, and dimensionality reduction are unsupervised</strong> tasks.</li>
  <li><strong>Parameters</strong> refer to the values, <strong>we want to estimate</strong> in a machine learning model.</li>
  <li>The <strong>process of estimating the values of the parameters</strong> is called the <strong>training or learning</strong> process.</li>
  <li>An <strong>objective function</strong> is a <strong>measure of the performance</strong> of our model.</li>
</ul>
:ET